{
  final Observable<Geocache> allCaches;
  final Subscription generator;
  if (Settings.isStoreOfflineMaps()) {
    final ReplaySubject<Geocache> withStaticMaps=ReplaySubject.create(caches.size());
    final ReplaySubject<Geocache> withoutStaticMaps=ReplaySubject.create(caches.size());
    final Worker worker=Schedulers.io().createWorker();
    generator=worker.schedule(new Action0(){
      @Override public void call(){
        for (        final Geocache cache : caches) {
          if (worker.isUnsubscribed()) {
            return;
          }
          if (cache.hasStaticMap()) {
            withStaticMaps.onNext(cache);
          }
 else {
            withoutStaticMaps.onNext(cache);
          }
        }
        withStaticMaps.onCompleted();
        withoutStaticMaps.onCompleted();
      }
    }
);
    allCaches=Observable.concat(withoutStaticMaps,withStaticMaps);
  }
 else {
    allCaches=Observable.from(caches);
    generator=Subscriptions.empty();
  }
  final Observable<Geocache> loaded=allCaches.flatMap(new Func1<Geocache,Observable<Geocache>>(){
    @Override public Observable<Geocache> call(    final Geocache cache){
      return Observable.create(new OnSubscribe<Geocache>(){
        @Override public void call(        final Subscriber<? super Geocache> subscriber){
          cache.refreshSynchronous(null);
          detailProgress.incrementAndGet();
          handler.obtainMessage(DownloadProgress.MSG_LOADED,cache).sendToTarget();
          subscriber.onCompleted();
        }
      }
).subscribeOn(RxUtils.refreshScheduler);
    }
  }
).doOnCompleted(new Action0(){
    @Override public void call(){
      handler.sendEmptyMessage(DownloadProgress.MSG_DONE);
    }
  }
);
  handler.unsubscribeIfCancelled(new CompositeSubscription(generator,loaded.subscribe()));
}
