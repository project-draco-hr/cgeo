{
  final Observable<Geocache> allCaches;
  if (Settings.isStoreOfflineMaps()) {
    final List<Geocache> withStaticMaps=new ArrayList<>(caches.size());
    final List<Geocache> withoutStaticMaps=new ArrayList<>(caches.size());
    for (    final Geocache cache : caches) {
      if (cache.hasStaticMap()) {
        withStaticMaps.add(cache);
      }
 else {
        withoutStaticMaps.add(cache);
      }
    }
    allCaches=Observable.concat(Observable.from(withoutStaticMaps),Observable.from(withStaticMaps));
  }
 else {
    allCaches=Observable.from(caches);
  }
  final Observable<Geocache> loaded=allCaches.flatMap(new Func1<Geocache,Observable<Geocache>>(){
    @Override public Observable<Geocache> call(    final Geocache cache){
      return Observable.create(new OnSubscribe<Geocache>(){
        @Override public void call(        final Subscriber<? super Geocache> subscriber){
          cache.refreshSynchronous(null);
          detailProgress.incrementAndGet();
          handler.obtainMessage(DownloadProgress.MSG_LOADED,cache).sendToTarget();
          subscriber.onCompleted();
        }
      }
).subscribeOn(AndroidRxUtils.refreshScheduler);
    }
  }
).doOnCompleted(new Action0(){
    @Override public void call(){
      handler.sendEmptyMessage(DownloadProgress.MSG_DONE);
    }
  }
);
  handler.unsubscribeIfCancelled(loaded.subscribe());
}
