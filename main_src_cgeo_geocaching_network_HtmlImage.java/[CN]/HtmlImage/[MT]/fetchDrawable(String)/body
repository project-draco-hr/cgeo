{
  if (StringUtils.isBlank(url) || ImageUtils.containsPattern(url,BLOCKED)) {
    return Observable.from(getTransparent1x1Image(resources));
  }
  if (url.startsWith("file://")) {
    return Async.fromCallable(new Func0<BitmapDrawable>(){
      @Override public BitmapDrawable call(){
        final Bitmap bitmap=loadCachedImage(new File(url.substring(7)),true).getLeft();
        return bitmap != null ? ImageUtils.scaleBitmapToFitDisplay(bitmap) : null;
      }
    }
,RxUtils.computationScheduler);
  }
  final boolean shared=url.contains("/images/icons/icon_");
  final String pseudoGeocode=shared ? SHARED : geocode;
  return Observable.create(new OnSubscribe<BitmapDrawable>(){
    @Override public void call(    final Subscriber<? super BitmapDrawable> subscriber){
      subscription.add(subscriber);
      subscriber.add(RxUtils.computationScheduler.schedule(new Action1<Inner>(){
        @Override public void call(        final Inner inner){
          final Pair<BitmapDrawable,Boolean> loaded=loadFromDisk();
          final BitmapDrawable bitmap=loaded.getLeft();
          if (loaded.getRight()) {
            subscriber.onNext(bitmap);
            subscriber.onCompleted();
            return;
          }
          if (bitmap != null && !onlySave) {
            subscriber.onNext(bitmap);
          }
          subscriber.add(downloadScheduler.schedule(new Action1<Inner>(){
            @Override public void call(            final Inner inner){
              downloadAndSave(subscriber);
            }
          }
));
        }
      }
));
    }
    private Pair<BitmapDrawable,Boolean> loadFromDisk(){
      final Pair<Bitmap,Boolean> loadResult=loadImageFromStorage(url,pseudoGeocode,shared);
      final Bitmap bitmap=loadResult.getLeft();
      return new ImmutablePair<BitmapDrawable,Boolean>(bitmap != null ? ImageUtils.scaleBitmapToFitDisplay(bitmap) : null,loadResult.getRight());
    }
    private void downloadAndSave(    final Subscriber<? super BitmapDrawable> subscriber){
      final File file=LocalStorage.getStorageFile(pseudoGeocode,url,true,true);
      if (url.startsWith("data:image/")) {
        if (url.contains(";base64,")) {
          ImageUtils.decodeBase64ToFile(StringUtils.substringAfter(url,";base64,"),file);
        }
 else {
          Log.e("HtmlImage.getDrawable: unable to decode non-base64 inline image");
          subscriber.onCompleted();
          return;
        }
      }
 else {
        if (subscriber.isUnsubscribed() || downloadOrRefreshCopy(url,file)) {
          subscriber.onCompleted();
          return;
        }
      }
      if (onlySave) {
        subscriber.onCompleted();
      }
 else {
        RxUtils.computationScheduler.schedule(new Action1<Inner>(){
          @Override public void call(          final Inner inner){
            final Pair<BitmapDrawable,Boolean> loaded=loadFromDisk();
            final BitmapDrawable image=loaded.getLeft();
            if (image != null) {
              subscriber.onNext(image);
            }
 else {
              subscriber.onNext(returnErrorImage ? new BitmapDrawable(resources,BitmapFactory.decodeResource(resources,R.drawable.image_not_loaded)) : getTransparent1x1Image(resources));
            }
            subscriber.onCompleted();
          }
        }
);
      }
    }
  }
);
}
