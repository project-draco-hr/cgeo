{
  final boolean shared=url.contains("/images/icons/icon_");
  final String pseudoGeocode=shared ? SHARED : geocode;
  final Observable<Pair<BitmapDrawable,Boolean>> loadFromDisk=Observable.create(new OnSubscribeFunc<Pair<BitmapDrawable,Boolean>>(){
    @Override public Subscription onSubscribe(    final Observer<? super Pair<BitmapDrawable,Boolean>> observer){
      final Pair<Bitmap,Boolean> loadResult=loadImageFromStorage(url,pseudoGeocode,shared);
      final Bitmap bitmap=loadResult.getLeft();
      observer.onNext(new ImmutablePair<BitmapDrawable,Boolean>(bitmap != null ? ImageUtils.scaleBitmapToFitDisplay(bitmap) : null,loadResult.getRight()));
      observer.onCompleted();
      return Subscriptions.empty();
    }
  }
).subscribeOn(Schedulers.computation());
  final Observable<BitmapDrawable> downloadAndSave=Observable.create(new OnSubscribeFunc<BitmapDrawable>(){
    @Override public Subscription onSubscribe(    final Observer<? super BitmapDrawable> observer){
      final File file=LocalStorage.getStorageFile(pseudoGeocode,url,true,true);
      if (url.startsWith("data:image/")) {
        if (url.contains(";base64,")) {
          saveBase64ToFile(url,file);
        }
 else {
          Log.e("HtmlImage.getDrawable: unable to decode non-base64 inline image");
          observer.onCompleted();
          return Subscriptions.empty();
        }
      }
 else {
        if (subscription.isUnsubscribed() || downloadOrRefreshCopy(url,file)) {
          observer.onCompleted();
          return Subscriptions.empty();
        }
      }
      if (onlySave) {
        observer.onCompleted();
      }
 else {
        loadFromDisk.map(new Func1<Pair<BitmapDrawable,Boolean>,BitmapDrawable>(){
          @Override public BitmapDrawable call(          final Pair<BitmapDrawable,Boolean> loadResult){
            final BitmapDrawable image=loadResult.getLeft();
            if (image != null) {
              return image;
            }
            return returnErrorImage ? new BitmapDrawable(resources,BitmapFactory.decodeResource(resources,R.drawable.image_not_loaded)) : getTransparent1x1Image(resources);
          }
        }
).subscribe(observer);
      }
      return Subscriptions.empty();
    }
  }
).subscribeOn(downloadScheduler);
  if (StringUtils.isBlank(url) || isCounter(url)) {
    return Observable.from(getTransparent1x1Image(resources));
  }
  return loadFromDisk.switchMap(new Func1<Pair<BitmapDrawable,Boolean>,Observable<? extends BitmapDrawable>>(){
    @Override public Observable<? extends BitmapDrawable> call(    final Pair<BitmapDrawable,Boolean> loadResult){
      final BitmapDrawable bitmap=loadResult.getLeft();
      if (loadResult.getRight()) {
        return Observable.from(bitmap);
      }
      return bitmap != null && !onlySave ? downloadAndSave.startWith(bitmap) : downloadAndSave;
    }
  }
);
}
