{
  super.onCreate(savedInstanceState);
  app.setAction(action);
  setTheme();
  setContentView(R.layout.caches);
  setTitle("caches");
  final Bundle extras=getIntent().getExtras();
  if (extras != null) {
    Object typeObject=extras.get(EXTRAS_LIST_TYPE);
    type=(typeObject instanceof CacheListType) ? (CacheListType)typeObject : CacheListType.OFFLINE;
    coords=new Geopoint(extras.getDouble("latitude"),extras.getDouble("longitude"));
    cachetype=Settings.getCacheType();
    keyword=extras.getString("keyword");
    address=extras.getString("address");
    username=extras.getString("username");
  }
  init();
  Thread threadPure;
  cgSearchThread thread;
switch (type) {
case OFFLINE:
    listId=Settings.getLastList();
  if (listId <= 0) {
    listId=cgList.STANDARD_LIST_ID;
    title=res.getString(R.string.caches_stored);
  }
 else {
    final cgList list=app.getList(listId);
    title=list.title;
  }
setTitle(title);
showProgress(true);
setLoadingCaches();
threadPure=new geocachesLoadByOffline(loadCachesHandler,coords,listId);
threadPure.start();
break;
case HISTORY:
if (adapter != null) {
adapter.setHistoric(true);
}
title=res.getString(R.string.caches_history);
setTitle(title);
showProgress(true);
setLoadingCaches();
threadPure=new geocachesLoadByHistory(loadCachesHandler);
threadPure.start();
break;
case NEAREST:
action="pending";
title=res.getString(R.string.caches_nearby);
setTitle(title);
showProgress(true);
setLoadingCaches();
thread=new geocachesLoadByCoords(loadCachesHandler,coords,cachetype);
thread.setRecaptchaHandler(new cgSearchHandler(this,res,thread));
thread.start();
break;
case COORDINATE:
action="planning";
title=coords.format(GeopointFormatter.Format.LAT_LON_DECMINUTE_PIPE);
setTitle(title);
showProgress(true);
setLoadingCaches();
thread=new geocachesLoadByCoords(loadCachesHandler,coords,cachetype);
thread.setRecaptchaHandler(new cgSearchHandler(this,res,thread));
thread.start();
break;
case KEYWORD:
title=keyword;
setTitle(title);
showProgress(true);
setLoadingCaches();
thread=new geocachesLoadByKeyword(loadCachesHandler,keyword,cachetype);
thread.setRecaptchaHandler(new cgSearchHandler(this,res,thread));
thread.start();
break;
case ADDRESS:
action="planning";
if (StringUtils.isNotBlank(address)) {
title=address;
setTitle(title);
showProgress(true);
setLoadingCaches();
}
 else {
title=coords.format(GeopointFormatter.Format.LAT_LON_DECMINUTE_PIPE);
setTitle(title);
showProgress(true);
setLoadingCaches();
}
thread=new geocachesLoadByCoords(loadCachesHandler,coords,cachetype);
thread.setRecaptchaHandler(new cgSearchHandler(this,res,thread));
thread.start();
break;
case USERNAME:
title=username;
setTitle(title);
showProgress(true);
setLoadingCaches();
thread=new geocachesLoadByUserName(loadCachesHandler,username,cachetype);
thread.setRecaptchaHandler(new cgSearchHandler(this,res,thread));
thread.start();
break;
case OWNER:
title=username;
setTitle(title);
showProgress(true);
setLoadingCaches();
thread=new geocachesLoadByOwner(loadCachesHandler,username,cachetype);
thread.setRecaptchaHandler(new cgSearchHandler(this,res,thread));
thread.start();
break;
case MAP:
title=res.getString(R.string.map_map);
setTitle(title);
showProgress(true);
search=extras != null ? (cgSearch)extras.get("search") : null;
loadCachesHandler.sendMessage(Message.obtain());
break;
default :
title="caches";
setTitle(title);
Log.e(Settings.tag,"cgeocaches.onCreate: No action or unknown action specified");
break;
}
prepareFilterBar();
}
