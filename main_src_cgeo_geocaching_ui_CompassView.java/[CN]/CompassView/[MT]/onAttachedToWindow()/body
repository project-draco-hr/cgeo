{
  final Resources res=context.getResources();
  compassUnderlay=BitmapFactory.decodeResource(res,R.drawable.compass_underlay);
  compassRose=BitmapFactory.decodeResource(res,R.drawable.compass_rose);
  compassArrow=BitmapFactory.decodeResource(res,R.drawable.compass_arrow);
  compassOverlay=BitmapFactory.decodeResource(res,R.drawable.compass_overlay);
  compassUnderlayWidth=compassUnderlay.getWidth();
  compassUnderlayHeight=compassUnderlay.getWidth();
  compassRoseWidth=compassRose.getWidth();
  compassRoseHeight=compassRose.getWidth();
  compassArrowWidth=compassArrow.getWidth();
  compassArrowHeight=compassArrow.getWidth();
  compassOverlayWidth=compassOverlay.getWidth();
  compassOverlayHeight=compassOverlay.getWidth();
  setfil=new PaintFlagsDrawFilter(0,Paint.FILTER_BITMAP_FLAG);
  remfil=new PaintFlagsDrawFilter(Paint.FILTER_BITMAP_FLAG,0);
synchronized (this) {
    initialDisplay=true;
  }
  periodicUpdate=Schedulers.io().schedulePeriodically(new Action1<Scheduler.Inner>(){
    @Override public void call(    final Scheduler.Inner inner){
synchronized (CompassView.this) {
        final float newAzimuthShown=smoothUpdate(northMeasured,azimuthShown);
        final float newCacheHeadingShown=smoothUpdate(cacheHeadingMeasured,cacheHeadingShown);
        if (Math.abs(AngleUtils.difference(azimuthShown,newAzimuthShown)) >= 2 || Math.abs(AngleUtils.difference(cacheHeadingShown,newCacheHeadingShown)) >= 2) {
          azimuthShown=newAzimuthShown;
          cacheHeadingShown=newCacheHeadingShown;
          postInvalidate();
        }
      }
    }
  }
,0,40,TimeUnit.MILLISECONDS);
}
