{
  final SearchResult searchResult=new SearchResult();
  try {
    if (StringUtils.isEmpty(data)) {
      throw new JSONException("No page given");
    }
    final JSONObject json=new JSONObject(data);
    final JSONArray grid=json.getJSONArray("grid");
    if (grid == null || grid.length() != (UTFGrid.GRID_MAXY + 1)) {
      throw new JSONException("No grid inside JSON");
    }
    final JSONArray keys=json.getJSONArray("keys");
    if (keys == null) {
      throw new JSONException("No keys inside JSON");
    }
    final JSONObject dataObject=json.getJSONObject("data");
    if (dataObject == null) {
      throw new JSONException("No data inside JSON");
    }
    Map<String,UTFGridPosition> keyPositions=new HashMap<String,UTFGridPosition>();
    for (int y=0; y < grid.length(); y++) {
      String rowUTF8=grid.getString(y);
      if (rowUTF8.length() != (UTFGrid.GRID_MAXX + 1)) {
        throw new JSONException("Grid has wrong size");
      }
      for (int x=0; x < UTFGrid.GRID_MAXX; x++) {
        char c=rowUTF8.charAt(x);
        if (c != ' ') {
          short id=UTFGrid.getUTFGridId(c);
          keyPositions.put(keys.getString(id),new UTFGridPosition(x,y));
        }
      }
    }
    Map<String,cgCache> caches=new HashMap<String,cgCache>();
    Map<String,List<UTFGridPosition>> positions=new HashMap<String,List<UTFGridPosition>>();
    for (int i=1; i < keys.length(); i++) {
      String key=keys.getString(i);
      if (StringUtils.isNotBlank(key)) {
        JSONArray dataForKey=dataObject.getJSONArray(key);
        for (int j=0; j < dataForKey.length(); j++) {
          JSONObject cacheInfo=dataForKey.getJSONObject(j);
          String id=cacheInfo.getString("i");
          cgCache cache=caches.get(id);
          if (cache == null) {
            cache=new cgCache();
            cache.setDetailed(false);
            cache.setReliableLatLon(false);
            cache.setGeocode(newidToGeocode(id));
            cache.setName(cacheInfo.getString("n"));
            cache.setType(CacheType.GC_LIVE_MAP);
            caches.put(id,cache);
          }
          List<UTFGridPosition> listOfPositions=positions.get(id);
          if (listOfPositions == null) {
            listOfPositions=new ArrayList<UTFGridPosition>();
          }
          UTFGridPosition pos=keyPositions.get(key);
          if (pos == null) {
            Log.e(Settings.tag,"key " + key + " not found in keyPositions");
          }
 else {
            listOfPositions.add(pos);
          }
          positions.put(id,listOfPositions);
        }
      }
    }
    for (    String id : positions.keySet()) {
      List<UTFGridPosition> pos=positions.get(id);
      cgCache cache=caches.get(id);
      cache.setCoords(getCoordsForUTFGrid(tile,pos));
      Log.d(Settings.tag,"id=" + id + " geocode="+ cache.getGeocode()+ " coords="+ cache.getCoords().toString());
      searchResult.addCache(cache);
    }
    Log.d(Settings.tag,"Retrieved " + searchResult.getCount() + " caches for tile "+ tile.toString());
  }
 catch (  Exception e) {
    Log.e(Settings.tag,"GCBase.parseMapJSON",e);
  }
  return searchResult;
}
