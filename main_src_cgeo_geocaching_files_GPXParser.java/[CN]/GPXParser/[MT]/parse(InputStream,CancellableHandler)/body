{
  final RootElement root=new RootElement(namespace,"gpx");
  final Element waypoint=root.getChild(namespace,"wpt");
  waypoint.setStartElementListener(new StartElementListener(){
    @Override public void start(    Attributes attrs){
      try {
        if (attrs.getIndex("lat") > -1 && attrs.getIndex("lon") > -1) {
          cache.setCoords(new Geopoint(new Double(attrs.getValue("lat")),new Double(attrs.getValue("lon"))));
        }
      }
 catch (      Exception e) {
        Log.w(Settings.tag,"Failed to parse waypoint's latitude and/or longitude.");
      }
    }
  }
);
  waypoint.setEndElementListener(new EndElementListener(){
    @Override public void end(){
      if (StringUtils.isBlank(cache.getGeocode())) {
        findGeoCode(name);
        findGeoCode(desc);
        findGeoCode(cmt);
      }
      if (StringUtils.isBlank(cache.getGeocode())) {
        if (StringUtils.isNotBlank(name)) {
          cache.setGeocode(name.trim());
        }
      }
      if (StringUtils.isNotBlank(cache.getGeocode()) && cache.getCoords() != null && ((type == null && sym == null) || StringUtils.contains(type,"geocache") || StringUtils.contains(sym,"geocache"))) {
        fixCache(cache);
        cache.setReason(listId);
        cache.setDetailed(true);
        createNoteFromGSAKUserdata();
        result.put(cache.getGeocode(),cache);
        showProgressMessage(progressHandler,progressStream.getProgress());
      }
 else       if (StringUtils.isNotBlank(cache.getName()) && cache.getCoords() != null && StringUtils.contains(type,"waypoint")) {
        addWaypointToCache();
      }
      resetCache();
    }
    private void addWaypointToCache(){
      fixCache(cache);
      if (cache.getName().length() > 2) {
        final String cacheGeocodeForWaypoint="GC" + cache.getName().substring(2);
        final cgCache cacheForWaypoint=result.get(cacheGeocodeForWaypoint);
        if (cacheForWaypoint != null) {
          final cgWaypoint waypoint=new cgWaypoint();
          waypoint.setId(-1);
          waypoint.setWaypointType(convertWaypointSym2Type(sym));
          waypoint.setGeocode(cacheGeocodeForWaypoint);
          waypoint.setPrefix(cache.getName().substring(0,2));
          waypoint.setLookup("---");
          waypoint.setName(cache.getShortdesc());
          waypoint.setCoords(cache.getCoords());
          waypoint.setNote(cache.getDescription());
          if (cacheForWaypoint.getWaypoints() == null) {
            cacheForWaypoint.setWaypoints(new ArrayList<cgWaypoint>());
          }
          cgWaypoint.mergeWayPoints(cacheForWaypoint.getWaypoints(),Collections.singletonList(waypoint));
          result.put(cacheGeocodeForWaypoint,cacheForWaypoint);
          showProgressMessage(progressHandler,progressStream.getProgress());
        }
      }
    }
  }
);
  waypoint.getChild(namespace,"time").setEndTextElementListener(new EndTextElementListener(){
    @Override public void end(    String body){
      try {
        cache.setHidden(parseDate(body));
      }
 catch (      Exception e) {
        Log.w(Settings.tag,"Failed to parse cache date: " + e.toString());
      }
    }
  }
);
  waypoint.getChild(namespace,"name").setEndTextElementListener(new EndTextElementListener(){
    @Override public void end(    String body){
      name=body;
      final String content=body.trim();
      cache.setName(content);
      findGeoCode(cache.getName());
    }
  }
);
  waypoint.getChild(namespace,"desc").setEndTextElementListener(new EndTextElementListener(){
    @Override public void end(    String body){
      desc=body;
      cache.setShortdesc(validate(body));
    }
  }
);
  waypoint.getChild(namespace,"cmt").setEndTextElementListener(new EndTextElementListener(){
    @Override public void end(    String body){
      cmt=body;
      cache.setDescription(validate(body));
    }
  }
);
  waypoint.getChild(namespace,"type").setEndTextElementListener(new EndTextElementListener(){
    @Override public void end(    String body){
      final String[] content=body.split("\\|");
      if (content.length > 0) {
        type=content[0].toLowerCase().trim();
      }
    }
  }
);
  waypoint.getChild(namespace,"sym").setEndTextElementListener(new EndTextElementListener(){
    @Override public void end(    final String body){
      sym=body.toLowerCase();
      if (sym.contains("geocache") && sym.contains("found")) {
        cache.setFound(true);
      }
    }
  }
);
  waypoint.getChild(namespace,"url").setEndTextElementListener(new EndTextElementListener(){
    @Override public void end(    String url){
      final Matcher matcher=patternGuid.matcher(url);
      if (matcher.matches()) {
        final String guid=matcher.group(1);
        if (StringUtils.isNotBlank(guid)) {
          cache.setGuid(guid);
        }
      }
    }
  }
);
  final Element cacheParent=getCacheParent(waypoint);
  final Element gsak=cacheParent.getChild(GSAK_NS,"wptExtension");
  gsak.getChild(GSAK_NS,"Watch").setEndTextElementListener(new EndTextElementListener(){
    @Override public void end(    String watchList){
      cache.setOnWatchlist(Boolean.valueOf(watchList.trim()).booleanValue());
    }
  }
);
  gsak.getChild(GSAK_NS,"UserData").setEndTextElementListener(new UserDataListener(1));
  for (int i=2; i <= 4; i++) {
    gsak.getChild(GSAK_NS,"User" + i).setEndTextElementListener(new UserDataListener(i));
  }
  for (  String nsGC : nsGCList) {
    final Element gcCache=cacheParent.getChild(nsGC,"cache");
    gcCache.setStartElementListener(new StartElementListener(){
      @Override public void start(      Attributes attrs){
        try {
          if (attrs.getIndex("id") > -1) {
            cache.setCacheId(attrs.getValue("id"));
          }
          if (attrs.getIndex("archived") > -1) {
            cache.setArchived(attrs.getValue("archived").equalsIgnoreCase("true"));
          }
          if (attrs.getIndex("available") > -1) {
            cache.setDisabled(!attrs.getValue("available").equalsIgnoreCase("true"));
          }
        }
 catch (        Exception e) {
          Log.w(Settings.tag,"Failed to parse cache attributes.");
        }
      }
    }
);
    gcCache.getChild(nsGC,"name").setEndTextElementListener(new EndTextElementListener(){
      @Override public void end(      String cacheName){
        cache.setName(validate(cacheName));
      }
    }
);
    gcCache.getChild(nsGC,"owner").setEndTextElementListener(new EndTextElementListener(){
      @Override public void end(      String cacheOwner){
        cache.setOwner(validate(cacheOwner));
      }
    }
);
    gcCache.getChild(nsGC,"type").setEndTextElementListener(new EndTextElementListener(){
      @Override public void end(      String body){
        cache.setType(CacheType.getByPattern(validate(body.toLowerCase())));
      }
    }
);
    gcCache.getChild(nsGC,"container").setEndTextElementListener(new EndTextElementListener(){
      @Override public void end(      String body){
        cache.setSize(CacheSize.getById(validate(body.toLowerCase())));
      }
    }
);
    final Element gcAttributes=gcCache.getChild(nsGC,"attributes");
    final Element gcAttribute=gcAttributes.getChild(nsGC,"attribute");
    gcAttribute.setStartElementListener(new StartElementListener(){
      @Override public void start(      Attributes attrs){
        try {
          if (attrs.getIndex("id") > -1 && attrs.getIndex("inc") > -1) {
            int attributeId=Integer.parseInt(attrs.getValue("id"));
            boolean attributeActive=Integer.parseInt(attrs.getValue("inc")) != 0;
            String internalId=CacheAttributeTranslator.getInternalId(attributeId,attributeActive);
            if (internalId != null) {
              if (cache.getAttributes() == null) {
                cache.setAttributes(new ArrayList<String>());
              }
              cache.getAttributes().add(internalId);
            }
          }
        }
 catch (        NumberFormatException e) {
        }
      }
    }
);
    gcCache.getChild(nsGC,"difficulty").setEndTextElementListener(new EndTextElementListener(){
      @Override public void end(      String body){
        try {
          cache.setDifficulty(Float.parseFloat(body));
        }
 catch (        NumberFormatException e) {
          Log.w(Settings.tag,"Failed to parse difficulty: " + e.toString());
        }
      }
    }
);
    gcCache.getChild(nsGC,"terrain").setEndTextElementListener(new EndTextElementListener(){
      @Override public void end(      String body){
        try {
          cache.setTerrain(Float.parseFloat(body));
        }
 catch (        NumberFormatException e) {
          Log.w(Settings.tag,"Failed to parse terrain: " + e.toString());
        }
      }
    }
);
    gcCache.getChild(nsGC,"country").setEndTextElementListener(new EndTextElementListener(){
      @Override public void end(      String country){
        if (StringUtils.isBlank(cache.getLocation())) {
          cache.setLocation(validate(country));
        }
 else {
          cache.setLocation(cache.getLocation() + ", " + country.trim());
        }
      }
    }
);
    gcCache.getChild(nsGC,"state").setEndTextElementListener(new EndTextElementListener(){
      @Override public void end(      String state){
        String trimmedState=state.trim();
        if (StringUtils.isNotEmpty(trimmedState)) {
          if (StringUtils.isBlank(cache.getLocation())) {
            cache.setLocation(validate(state));
          }
 else {
            cache.setLocation(trimmedState + ", " + cache.getLocation());
          }
        }
      }
    }
);
    gcCache.getChild(nsGC,"encoded_hints").setEndTextElementListener(new EndTextElementListener(){
      @Override public void end(      String encoded){
        cache.setHint(validate(encoded));
      }
    }
);
    gcCache.getChild(nsGC,"short_description").setEndTextElementListener(new EndTextElementListener(){
      @Override public void end(      String shortDesc){
        cache.setShortdesc(validate(shortDesc));
      }
    }
);
    gcCache.getChild(nsGC,"long_description").setEndTextElementListener(new EndTextElementListener(){
      @Override public void end(      String desc){
        cache.setDescription(validate(desc));
      }
    }
);
    final Element gcTBs=gcCache.getChild(nsGC,"travelbugs");
    final Element gcTB=gcTBs.getChild(nsGC,"travelbug");
    gcTB.setStartElementListener(new StartElementListener(){
      @Override public void start(      Attributes attrs){
        trackable=new cgTrackable();
        try {
          if (attrs.getIndex("ref") > -1) {
            trackable.setGeocode(attrs.getValue("ref").toUpperCase());
          }
        }
 catch (        Exception e) {
        }
      }
    }
);
    gcTB.setEndElementListener(new EndElementListener(){
      @Override public void end(){
        if (StringUtils.isNotBlank(trackable.getGeocode()) && StringUtils.isNotBlank(trackable.getName())) {
          if (cache.getInventory() == null) {
            cache.setInventory(new ArrayList<cgTrackable>());
          }
          cache.getInventory().add(trackable);
        }
      }
    }
);
    gcTB.getChild(nsGC,"name").setEndTextElementListener(new EndTextElementListener(){
      @Override public void end(      String tbName){
        trackable.setName(validate(tbName));
      }
    }
);
    final Element gcLogs=gcCache.getChild(nsGC,"logs");
    final Element gcLog=gcLogs.getChild(nsGC,"log");
    gcLog.setStartElementListener(new StartElementListener(){
      @Override public void start(      Attributes attrs){
        log=new cgLog();
        try {
          if (attrs.getIndex("id") > -1) {
            log.id=Integer.parseInt(attrs.getValue("id"));
          }
        }
 catch (        Exception e) {
        }
      }
    }
);
    gcLog.setEndElementListener(new EndElementListener(){
      @Override public void end(){
        if (StringUtils.isNotBlank(log.log)) {
          if (cache.getLogs() == null) {
            cache.setLogs(new ArrayList<cgLog>());
          }
          cache.getLogs().add(log);
        }
      }
    }
);
    gcLog.getChild(nsGC,"date").setEndTextElementListener(new EndTextElementListener(){
      @Override public void end(      String body){
        try {
          log.date=parseDate(body).getTime();
        }
 catch (        Exception e) {
          Log.w(Settings.tag,"Failed to parse log date: " + e.toString());
        }
      }
    }
);
    gcLog.getChild(nsGC,"type").setEndTextElementListener(new EndTextElementListener(){
      @Override public void end(      String body){
        final String logType=validate(body).toLowerCase();
        log.type=LogType.getByType(logType);
      }
    }
);
    gcLog.getChild(nsGC,"finder").setEndTextElementListener(new EndTextElementListener(){
      @Override public void end(      String finderName){
        log.author=validate(finderName);
      }
    }
);
    gcLog.getChild(nsGC,"text").setEndTextElementListener(new EndTextElementListener(){
      @Override public void end(      String logText){
        log.log=validate(logText);
      }
    }
);
  }
  try {
    progressStream=new ProgressInputStream(stream);
    Xml.parse(progressStream,Xml.Encoding.UTF_8,root.getContentHandler());
    return result.values();
  }
 catch (  SAXException e) {
    Log.e(Settings.tag,"Cannot parse .gpx file as GPX " + version + ": could not parse XML - "+ e.toString());
    throw new ParserException("Cannot parse .gpx file as GPX " + version + ": could not parse XML",e);
  }
}
