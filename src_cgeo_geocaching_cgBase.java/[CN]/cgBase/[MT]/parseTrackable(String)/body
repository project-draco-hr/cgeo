{
  if (page == null || page.length() == 0) {
    Log.e(cgSettings.tag,"cgeoBase.parseTrackable: No page given");
    return null;
  }
  final Pattern patternTrackableId=Pattern.compile("<a id=\"ctl00_ContentBody_LogLink\" title=\"[^\"]*\" href=\".*log\\.aspx\\?wid=([a-z0-9\\-]+)\"[^>]*>[^<]*</a>",Pattern.CASE_INSENSITIVE);
  final Pattern patternGeocode=Pattern.compile("<span id=\"ctl00_ContentBody_BugDetails_BugTBNum\" String=\"[^\"]*\">Use[^<]*<strong>(TB[0-9a-z]+)[^<]*</strong> to reference this item.[^<]*</span>",Pattern.CASE_INSENSITIVE);
  final Pattern patternName=Pattern.compile("<h2>([^<]*<img[^>]*>)?[^<]*<span id=\"ctl00_ContentBody_lbHeading\">([^<]+)</span>[^<]*</h2>",Pattern.CASE_INSENSITIVE);
  final Pattern patternOwner=Pattern.compile("<dt>\\W*Owner:[^<]*</dt>[^<]*<dd>[^<]*<a id=\"ctl00_ContentBody_BugDetails_BugOwner\" title=\"[^\"]*\" href=\"[^\"]*/profile/\\?guid=([a-z0-9\\-]+)\">([^<]+)<\\/a>[^<]*</dd>",Pattern.CASE_INSENSITIVE);
  final Pattern patternReleased=Pattern.compile("<dt>\\W*Released:[^<]*</dt>[^<]*<dd>[^<]*<span id=\"ctl00_ContentBody_BugDetails_BugReleaseDate\">([^<]+)<\\/span>[^<]*</dd>",Pattern.CASE_INSENSITIVE);
  final Pattern patternOrigin=Pattern.compile("<dt>\\W*Origin:[^<]*</dt>[^<]*<dd>[^<]*<span id=\"ctl00_ContentBody_BugDetails_BugOrigin\">([^<]+)<\\/span>[^<]*</dd>",Pattern.CASE_INSENSITIVE);
  final Pattern patternSpottedCache=Pattern.compile("<dt>\\W*Recently Spotted:[^<]*</dt>[^<]*<dd>[^<]*<a id=\"ctl00_ContentBody_BugDetails_BugLocation\" title=\"[^\"]*\" href=\"[^\"]*/seek/cache_details.aspx\\?guid=([a-z0-9\\-]+)\">In ([^<]+)</a>[^<]*</dd>",Pattern.CASE_INSENSITIVE);
  final Pattern patternSpottedUser=Pattern.compile("<dt>\\W*Recently Spotted:[^<]*</dt>[^<]*<dd>[^<]*<a id=\"ctl00_ContentBody_BugDetails_BugLocation\" href=\"[^\"]*/profile/\\?guid=([a-z0-9\\-]+)\">In the hands of ([^<]+).</a>[^<]*</dd>",Pattern.CASE_INSENSITIVE);
  final Pattern patternSpottedUnknown=Pattern.compile("<dt>\\W*Recently Spotted:[^<]*</dt>[^<]*<dd>[^<]*<a id=\"ctl00_ContentBody_BugDetails_BugLocation\">Unknown Location[^<]*</a>[^<]*</dd>",Pattern.CASE_INSENSITIVE);
  final Pattern patternSpottedOwner=Pattern.compile("<dt>\\W*Recently Spotted:[^<]*</dt>[^<]*<dd>[^<]*<a id=\"ctl00_ContentBody_BugDetails_BugLocation\">In the hands of the owner[^<]*</a>[^<]*</dd>",Pattern.CASE_INSENSITIVE);
  final Pattern patternGoal=Pattern.compile("<h3>\\W*Current GOAL[^<]*</h3>[^<]*<p[^>]*>(.*)</p>[^<]*<h3>\\W*About This Item[^<]*</h3>",Pattern.CASE_INSENSITIVE);
  final Pattern patternDetailsImage=Pattern.compile("<h3>\\W*About This Item[^<]*</h3>([^<]*<p>([^<]*<img id=\"ctl00_ContentBody_BugDetails_BugImage\" class=\"[^\"]+\" src=\"([^\"]+)\"[^>]*>)?[^<]*</p>)?[^<]*<p[^>]*>(.*)</p>[^<]*<div id=\"ctl00_ContentBody_BugDetails_uxAbuseReport\">",Pattern.CASE_INSENSITIVE);
  final Pattern patternLogs=Pattern.compile("<table class=\"TrackableItemLogTable Table\">(.*)<\\/table>[^<]*<ul",Pattern.CASE_INSENSITIVE);
  final Pattern patternIcon=Pattern.compile("<img id=\"ctl00_ContentBody_BugTypeImage\" class=\"TravelBugHeaderIcon\" src=\"([^\"]+)\"[^>]*>",Pattern.CASE_INSENSITIVE);
  final Pattern patternType=Pattern.compile("<img id=\"ctl00_ContentBody_BugTypeImage\" class=\"TravelBugHeaderIcon\" src=\"[^\"]+\" alt=\"([^\"]+)\"[^>]*>",Pattern.CASE_INSENSITIVE);
  final Pattern patternDistance=Pattern.compile("<h4[^>]*\\W*Tracking History \\(([0-9\\.,]+(km|mi))[^\\)]*\\)",Pattern.CASE_INSENSITIVE);
  final cgTrackable trackable=new cgTrackable();
  try {
    final Matcher matcherGeocode=patternGeocode.matcher(page);
    while (matcherGeocode.find()) {
      if (matcherGeocode.groupCount() > 0) {
        trackable.geocode=matcherGeocode.group(1).toUpperCase();
      }
    }
  }
 catch (  Exception e) {
    Log.w(cgSettings.tag,"cgeoBase.parseTrackable: Failed to parse trackable geocode");
  }
  try {
    final Matcher matcherTrackableId=patternTrackableId.matcher(page);
    while (matcherTrackableId.find()) {
      if (matcherTrackableId.groupCount() > 0) {
        trackable.guid=matcherTrackableId.group(1);
      }
    }
  }
 catch (  Exception e) {
    Log.w(cgSettings.tag,"cgeoBase.parseTrackable: Failed to parse trackable id");
  }
  try {
    final Matcher matcherTrackableIcon=patternIcon.matcher(page);
    while (matcherTrackableIcon.find()) {
      if (matcherTrackableIcon.groupCount() > 0) {
        trackable.iconUrl=matcherTrackableIcon.group(1);
      }
    }
  }
 catch (  Exception e) {
    Log.w(cgSettings.tag,"cgeoBase.parseTrackable: Failed to parse trackable icon");
  }
  try {
    final Matcher matcherName=patternName.matcher(page);
    while (matcherName.find()) {
      if (matcherName.groupCount() > 1) {
        trackable.name=matcherName.group(2);
      }
    }
  }
 catch (  Exception e) {
    Log.w(cgSettings.tag,"cgeoBase.parseTrackable: Failed to parse trackable name");
  }
  if (trackable.name != null && trackable.name.length() > 0) {
    try {
      final Matcher matcherType=patternType.matcher(page);
      while (matcherType.find()) {
        if (matcherType.groupCount() > 0) {
          trackable.type=matcherType.group(1);
        }
      }
    }
 catch (    Exception e) {
      Log.w(cgSettings.tag,"cgeoBase.parseTrackable: Failed to parse trackable type");
    }
  }
  try {
    final Matcher matcherOwner=patternOwner.matcher(page);
    while (matcherOwner.find()) {
      if (matcherOwner.groupCount() > 0) {
        trackable.ownerGuid=matcherOwner.group(1);
        trackable.owner=matcherOwner.group(2);
      }
    }
  }
 catch (  Exception e) {
    Log.w(cgSettings.tag,"cgeoBase.parseTrackable: Failed to parse trackable owner name");
  }
  try {
    final Matcher matcherOrigin=patternOrigin.matcher(page);
    while (matcherOrigin.find()) {
      if (matcherOrigin.groupCount() > 0) {
        trackable.origin=matcherOrigin.group(1);
      }
    }
  }
 catch (  Exception e) {
    Log.w(cgSettings.tag,"cgeoBase.parseTrackable: Failed to parse trackable origin");
  }
  try {
    final Matcher matcherSpottedCache=patternSpottedCache.matcher(page);
    while (matcherSpottedCache.find()) {
      if (matcherSpottedCache.groupCount() > 0) {
        trackable.spottedGuid=matcherSpottedCache.group(1);
        trackable.spottedName=matcherSpottedCache.group(2);
        trackable.spottedType=cgTrackable.SPOTTED_CACHE;
      }
    }
    final Matcher matcherSpottedUser=patternSpottedUser.matcher(page);
    while (matcherSpottedUser.find()) {
      if (matcherSpottedUser.groupCount() > 0) {
        trackable.spottedGuid=matcherSpottedUser.group(1);
        trackable.spottedName=matcherSpottedUser.group(2);
        trackable.spottedType=cgTrackable.SPOTTED_USER;
      }
    }
    final Matcher matcherSpottedUnknown=patternSpottedUnknown.matcher(page);
    if (matcherSpottedUnknown.find()) {
      trackable.spottedType=cgTrackable.SPOTTED_UNKNOWN;
    }
    final Matcher matcherSpottedOwner=patternSpottedOwner.matcher(page);
    if (matcherSpottedOwner.find()) {
      trackable.spottedType=cgTrackable.SPOTTED_OWNER;
    }
  }
 catch (  Exception e) {
    Log.w(cgSettings.tag,"cgeoBase.parseTrackable: Failed to parse trackable last known place");
  }
  try {
    final Matcher matcherReleased=patternReleased.matcher(page);
    while (matcherReleased.find()) {
      if (matcherReleased.groupCount() > 0 && matcherReleased.group(1) != null) {
        try {
          if (trackable.released == null) {
            trackable.released=dateTbIn1.parse(matcherReleased.group(1));
          }
        }
 catch (        Exception e) {
        }
        try {
          if (trackable.released == null) {
            trackable.released=dateTbIn2.parse(matcherReleased.group(1));
          }
        }
 catch (        Exception e) {
        }
      }
    }
  }
 catch (  Exception e) {
    Log.w(cgSettings.tag,"cgeoBase.parseTrackable: Failed to parse trackable released date");
  }
  try {
    final Matcher matcherDistance=patternDistance.matcher(page);
    while (matcherDistance.find()) {
      if (matcherDistance.groupCount() > 0) {
        trackable.distance=parseDistance(matcherDistance.group(1));
      }
    }
  }
 catch (  Exception e) {
    Log.w(cgSettings.tag,"cgeoBase.parseTrackable: Failed to parse trackable distance");
  }
  try {
    final Matcher matcherGoal=patternGoal.matcher(page);
    while (matcherGoal.find()) {
      if (matcherGoal.groupCount() > 0) {
        trackable.goal=matcherGoal.group(1);
      }
    }
  }
 catch (  Exception e) {
    Log.w(cgSettings.tag,"cgeoBase.parseTrackable: Failed to parse trackable goal");
  }
  try {
    final Matcher matcherDetailsImage=patternDetailsImage.matcher(page);
    while (matcherDetailsImage.find()) {
      if (matcherDetailsImage.groupCount() > 0) {
        final String image=matcherDetailsImage.group(3);
        final String details=matcherDetailsImage.group(4);
        if (image != null) {
          trackable.image=image;
        }
        if (details != null) {
          trackable.details=details;
        }
      }
    }
  }
 catch (  Exception e) {
    Log.w(cgSettings.tag,"cgeoBase.parseTrackable: Failed to parse trackable details & image");
  }
  try {
    final Matcher matcherLogs=patternLogs.matcher(page);
    while (matcherLogs.find()) {
      if (matcherLogs.groupCount() > 0) {
        final Pattern patternLog=Pattern.compile("[^>]*>" + "[^<]*<td[^<]*<img src=[\"|'].*\\/icons\\/([^\\.]+)\\.[a-z]{2,5}[\"|'][^>]*>&nbsp;(\\d+).(\\d+).(\\d+)[^<]*</td>" + "[^<]*<td>[^<]*<a href=[^>]+>([^<]+)<.a>([^<]*|[^<]*<a href=[\"|'].*guid=([^\"]*)\">([^<]*)</a>[^<]*)</td>"+ "[^<]*<td>[^<]*</td>"+ "[^<]*<td[^<]*<a href=[^>]+>[^<]+</a>[^<]*</td>[^<]*</tr>"+ "[^<]*<tr[^>]*>[^<]*<td[^>]*>(.*?)</td>[^<]*</tr>.*"+ "");
        final String[] logs=matcherLogs.group(1).split("<tr class=\"Data BorderTop");
        final int logsCnt=logs.length;
        for (int k=1; k < logsCnt; k++) {
          final Matcher matcherLog=patternLog.matcher(logs[k]);
          if (matcherLog.find()) {
            final cgLog logDone=new cgLog();
            String logTmp=matcherLog.group(9);
            logTmp=Pattern.compile("<p>").matcher(logTmp).replaceAll("\n");
            logTmp=Pattern.compile("<br[^>]*>").matcher(logTmp).replaceAll("\n");
            logTmp=Pattern.compile("<\\/p>").matcher(logTmp).replaceAll("");
            logTmp=Pattern.compile("\r+").matcher(logTmp).replaceAll("\n");
            int day=-1;
            try {
              day=Integer.parseInt(matcherLog.group(3));
            }
 catch (            Exception e) {
              Log.w(cgSettings.tag,"Failed to parse logs date (day): " + e.toString());
            }
            int month=-1;
            try {
              month=Integer.parseInt(matcherLog.group(2));
              month-=1;
            }
 catch (            Exception e) {
              Log.w(cgSettings.tag,"Failed to parse logs date (month): " + e.toString());
            }
            int year=-1;
            try {
              year=Integer.parseInt(matcherLog.group(4));
            }
 catch (            Exception e) {
              Log.w(cgSettings.tag,"Failed to parse logs date (year): " + e.toString());
            }
            long logDate;
            if (year > 0 && month >= 0 && day > 0) {
              Calendar date=Calendar.getInstance();
              date.set(year,month,day,12,0,0);
              logDate=date.getTimeInMillis();
              logDate=(logDate / 1000L) * 1000L;
            }
 else {
              logDate=0;
            }
            if (logTypes.containsKey(matcherLog.group(1).toLowerCase())) {
              logDone.type=logTypes.get(matcherLog.group(1).toLowerCase());
            }
 else {
              logDone.type=logTypes.get("icon_note");
            }
            logDone.author=Html.fromHtml(matcherLog.group(5)).toString();
            logDone.date=logDate;
            logDone.log=logTmp;
            if (matcherLog.group(7) != null && matcherLog.group(8) != null) {
              logDone.cacheGuid=matcherLog.group(7);
              logDone.cacheName=matcherLog.group(8);
            }
            trackable.logs.add(logDone);
          }
        }
      }
    }
  }
 catch (  Exception e) {
    Log.w(cgSettings.tag,"cgeoBase.parseCache: Failed to parse cache logs");
  }
  app.saveTrackable(trackable);
  return trackable;
}
